declare object Complex {

   property INPUT_DIFFERENTIALS : Array<Matrix>;
   
   property DIFFERENTIALS : Array<Matrix>;

   property HOMOLOGIES : Array<Matrix>;

   property BETTI_NUMBERS : Vector<Int>;

   property IS_WELLDEFINED : Bool; 

   rule DIFFERENTIALS : INPUT_DIFFERENTIALS {
      my @input = @{$this->INPUT_DIFFERENTIALS};
      my $n = @input;
      my $first = new Matrix(0,$input[0]->rows);
      my $last = new Matrix($input[$n-1]->cols,0);
      unshift @input, $first;
      push @input, $last;
      $this->DIFFERENTIALS = new Array<Matrix>(@input);
   }

   rule HOMOLOGIES : DIFFERENTIALS {
      my $differentials = $this->DIFFERENTIALS;
      my $homologies = new Array<Matrix>($differentials->size - 1);
      # print "Hello.\n";
      for(my $i = 0; $i<$differentials->size-1; $i++){
         $homologies->[$i] = compute_homology($differentials->[$i+1], $differentials->[$i]);
         print "Rows: ",$homologies->[$i]->rows," cols: ",$homologies->[$i]->cols,"\n";
      }
      $this->HOMOLOGIES = $homologies;
   }

   rule BETTI_NUMBERS : HOMOLOGIES {
      my $homologies = $this->HOMOLOGIES;
      my $betti_num = new Vector<Int>($homologies->size);
      for(my $i = 0; $i<$homologies->size; $i++){
         my $homology = $homologies->[$i];
         $betti_num->[$i] = $homology->rows()-rank($homology);
      }
      $this->BETTI_NUMBERS = $betti_num;
   }

   rule IS_WELLDEFINED : DIFFERENTIALS {
      my $differentials = $this->DIFFERENTIALS;
      for (my $i=0; $i<$differentials->size-1;$i++){
         if ($differentials->[$i]->cols != $differentials->[$i+1]->rows){
            $this->IS_WELLDEFINED = 0;
            print "Dimension mismatch at position ",$i,"\n";
            return;
         }
         else{
            my $test = $differentials->[$i]*$differentials->[$i+1];
            if($test != zero_matrix($test->rows,$test->cols)){
               $this->IS_WELLDEFINED =0;
               print "Not a differential at position ",$i,"\n";
               return;
            }
         }
      }
      $this->IS_WELLDEFINED = 1;
   }

   user_method wedge_complex( $ ){
      my($this, $p) = @_;
      my $old_differentials = $this->DIFFERENTIALS;
      my $new_differentials = new Array<Matrix>($this->DIFFERENTIALS->size()-1);
      for(my $i = 0; $i<$new_differentials->size; $i++){
         $new_differentials->[$i] = wedge_matrix($old_differentials->[$i],$p);
      }
      return new Complex(DIFFERENTIALS=>$new_differentials);
   }

}

sub wedge_matrix{
   my($A, $p) = @_;
   # print "Hello\n";
   my $n = $A->rows;
   my $m = $A->cols;
   if ($p <= $n && $p <= $m){
      my @rowBases = all_subsets_of_k($p, (0..$n -1));
      my @colBases = all_subsets_of_k($p, (0..$m -1));
      # print scalar @rowBases;
      print "\n";
      my @result = ();
      for(my $i=0; $i<@rowBases; $i++){
         my @tmp = ();
         for(my $j=0; $j<@colBases; $j++){
            push @tmp, det($A->minor($rowBases[$i], $colBases[$j]));
         }
         push @result, new Vector(@tmp);
      }
      return new Matrix(@result);
   }
   my $k = $n>=$p ? binomial($n,$p) : 0;
   my $l = $m>=$p ? binomial($m,$p) : 0;
   return( new Matrix($k,$l));
}


sub compute_homology{
   my($imof,$kerof) = @_;
   my $ker = null_space($kerof);
   my $relations = build_matrix($ker,transpose($imof));
   return transpose($relations);
}

sub compute_homology_dimension{
   my($imof, $kerof) = @_;
   my $homology = compute_homology($imof,$kerof);
   return $homology->rows()-rank($homology);
}

