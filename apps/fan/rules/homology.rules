

object PolyhedralComplex {

   property CHAIN_COMPLEX : Complex;

   property BLOCKS : Map<Pair<Set<Int>, Set<Int> >, Matrix >;

   property CHOSEN_BASES : Map<Set<Int>, Matrix>;

   property ORIENTATIONS : Map<Pair<Set<Int>, Set<Int> >, Int >;

   rule CHOSEN_BASES : VERTICES, HASSE_DIAGRAM, FAN_DIM {
      my $result = new Map<Set<Int>, Matrix>();
      my $d = $this->FAN_DIM - 1;
      my $vertices = $this->VERTICES;
      my $hd = $this->HASSE_DIAGRAM;
      for(my $i=0; $i<=$d; $i++){
         my $sigmaDim = $d - $i;
         # print "Looking at dim ",$sigmaDim,"\n";
         my $sigmas = $hd->nodes_of_dim($sigmaDim);
         foreach my $sigma (@$sigmas) {
            my $honestSigma = $hd->FACES->[$sigma];
            my $vIndex = $honestSigma->[0];
            my $v = $vertices->[$vIndex];
            my $generators = $vertices->minor($honestSigma, All);
            $generators = new Matrix(map($_-$v, @$generators));
            if($honestSigma->size == 1) {
               $result->{$honestSigma} = new Matrix(0, $d);
            } else {
               $result->{$honestSigma} = choose_basis($generators);
            }
         }
      }
      $this->CHOSEN_BASES = $result;
   }

   
   rule BLOCKS : HASSE_DIAGRAM, FAN_DIM, CHOSEN_BASES {
      my $result = new Map<Pair<Set<Int>, Set<Int> >, Matrix>();
      my $d = $this->FAN_DIM - 1;
      my $chosenBases = $this->CHOSEN_BASES;
      my $hd = $this->HASSE_DIAGRAM;
      # print $d,"\n";
      for(my $i=0; $i<$d; $i++){
         my $sigmas = $hd->nodes_of_dim($d-$i);
         my $taus = $hd->nodes_of_dim($d-$i-1);
         foreach my $sigma (@$sigmas) {
            my $honestSigma = $hd->FACES->[$sigma];
            foreach my $tau (@$taus) {
               my $honestTau = $hd->FACES->[$tau];
               my $keyPair = new Pair<Set<Int>, Set<Int> >($honestSigma, $honestTau);
               # print $honestSigma," - ",$honestTau," - ",compute_sign($honestSigma, $honestTau),"\n";
               my $sigmaBasis = $chosenBases->{$honestSigma};
               my $tauBasis = $chosenBases->{$honestTau};
               my $map;
               my $test = $honestSigma*$honestTau;
               if($test->size == $honestTau->size){
                  $map = build_matrix($sigmaBasis, $tauBasis);
               } else {
                  $map = new Matrix($tauBasis->rows, $sigmaBasis->rows);
               }
               $result->{$keyPair} = $map;
            }
         }
      }
      $this->BLOCKS = $result;
   }
   
    	
 	rule ORIENTATIONS : HASSE_DIAGRAM, FAN_DIM, BLOCKS, VERTICES, CHOSEN_BASES {
      # returns either 0, +1, -1 depending on the compatibility of thechosen ordered bases
      my $d = $this->FAN_DIM - 1;
      my $result = new Map<Pair<Set<Int>, Set<Int> >, Int>();
      my $blocks = $this->BLOCKS;
      my $vertices = $this->VERTICES;
      my $hd = $this->HASSE_DIAGRAM;
      my $chosenBases = $this->CHOSEN_BASES;
      # print $d,"\n";
      my $sign;
      for(my $i=0; $i<$d; $i++){
         my $sigmas = $hd->nodes_of_dim($d-$i);
         my $taus = $hd->nodes_of_dim($d-$i-1);
         foreach my $sigma (@$sigmas) {
            my $honestSigma = $hd->FACES->[$sigma];
            foreach my $tau (@$taus) {
               my $honestTau = $hd->FACES->[$tau];
               my $keyPair = new Pair<Set<Int>, Set<Int> >($honestSigma, $honestTau);
               my $test = $honestSigma*$honestTau;
               if($test->size == $honestTau->size){
                  my $honestNotInTau = $honestSigma - $honestTau;
                  my $indexNotInTau = $honestNotInTau->[0];
                  my $vectorNotInTau = $vertices->[$indexNotInTau];
                  my $genVector = $vectorNotInTau - $vertices->[$honestTau->[0]]; #This creates a vector in span of Sigma not in Tauand pointing same as Sigma
                  $genVector = new Matrix($genVector);
                  my $sigmaBasis = $chosenBases->{$honestSigma};
                  # print "SigmaBasis:\n", $sigmaBasis,"\n",$genVector,"\n";
                  my $relativeRow = new Matrix(build_matrix($sigmaBasis,  $genVector));
                  my $dxdMinus1 = $blocks->{$keyPair}; 
                  my $baseChangeMatrix = new Matrix($relativeRow / $dxdMinus1);   
                  if (det($baseChangeMatrix) >= 0){
                     $sign = 1;
                  } else {
                     $sign = -1;
                  }
               } else { 
                  $sign = 0;
               }
               $result->{$keyPair} = $sign;
            }
         } 
      }
      $this->ORIENTATIONS = $result;
   }

 	

   rule CHAIN_COMPLEX : HASSE_DIAGRAM, FAN_DIM, BLOCKS, ORIENTATIONS {
      my $d = $this->FAN_DIM - 1;
      my $result = new Array<Matrix>($d+1);
      my $hd = $this->HASSE_DIAGRAM;
      my $blocks = $this->BLOCKS;
      my $orientations = $this->ORIENTATIONS;
      for(my $i=0; $i<$d-1; $i++){
         my $sigmas = $hd->nodes_of_dim($d-$i);
         my $taus = $hd->nodes_of_dim($d-$i-1);
         # print "i: ", $i," Sigmas: ",$sigmas->size," Taus: ",$taus->size,"\n";
         my $chainmap = 0;
         my $outerinit = 0;
         foreach my $sigma (@$sigmas) {
            my $honestSigma = $hd->FACES->[$sigma];
            my $columns = 0;
            my $init = 0;
            foreach my $tau (@$taus) {
               my $honestTau = $hd->FACES->[$tau];
               my $keyPair = new Pair<Set<Int>, Set<Int> >($honestSigma, $honestTau);
               my $sign = $orientations->{$keyPair};
               if($init == 0){
                  $columns = $sign * $blocks->{$keyPair};
                  $init = 1;
               } else {
                  $columns = new Matrix($columns / ($sign * $blocks->{$keyPair}));
               }
            }
            if($outerinit == 0){
               $chainmap = $columns;
               $outerinit =1;
            } else {
               $chainmap = new Matrix($chainmap | $columns);
            }
         }
         # print "Rows: ",$chainmap->rows," Cols: ",$chainmap->cols,"\n";
         $result->[$d-$i] = new Matrix($chainmap);
      }
      $result->[1] = zero_matrix(0,$result->[2]->rows);
      $this->CHAIN_COMPLEX = new Complex(INPUT_DIFFERENTIALS=>$result);
   }

}


sub compute_sign{
   my($sigma, $tau) = @_;
   my $test = $sigma*$tau;
   $test->size == $tau->size or return 0;
   my $result = 1;
   for(my $i = 0; $i<$sigma->size; $i++){
      if($sigma->[$i] != $tau->[$i]){
         $result *= ($i%2 == 0) ? 1:-1;
         last;
      }
   }
   return $result;
}

sub build_matrix{
   my($bigger, $smaller) = @_;
   my @images = map{
      my $v = $_;
      my $C = $bigger/(-$v);
      my $image = null_space(transpose($C));
      $image->rows() == 1 or die("Something went wrong.".$image->rows());
      my $Cv = $image->[0];
      my $length = $Cv->dim - 1;
      my $last = $Cv->[$length];
      $Cv = $Cv->slice(0, $length);
      (1/$last) * $Cv
   }@$smaller;
   return new Matrix(@images);
}

sub build_cone{
   my($vertices, $indexSet, $common) = @_;
   # print "Building cone: ",$indexSet,"\n";
   my $rays = new Matrix($vertices->minor($indexSet, All));
   # print $rays,"----\n";
   my $v = $vertices->[$common];
   # print $v,"\n----\n";
   $rays = new Matrix(map{$_-$v}@$rays);
   $rays = $rays->minor(All, ~[0]);
   # print $rays;
   return new Cone(INPUT_RAYS=>$rays);
}

sub choose_basis{
   my($A) = @_;
   my @result = ();
   my $desired = rank($A);
   my $ambient = $A->cols();
   my $zero = zero_vector($ambient);
   my @gens = @$A;
   @gens = grep($_ != $zero, @gens);
   push @result, shift @gens;
   my $test = new Matrix(@result);
   while(rank($test) < $desired){
      my $next = shift @gens;
      if(rank($test / $next) > rank($test)){
         push @result, $next;
         $test = new Matrix(@result);
      }
   }
   return $test;
}


sub to_lattice_basis{
   my($A) = @_;
   my $Aint = new Matrix<Integer>(primitive($A));
   my ($D, $L, $R) = @{smith_normal_form($Aint)};
   return $R->minor([0..$A->rows()-1],All);
}
