#  Copyright (c) 2016-2018
#  Lars Kastner (TU Berlin)
#  Kristin Shaw (University of Oslo)
#  Anna-Lena Winz (FU Berlin)

#  This program is free software; you can redistribute it and/or modify it
#  under the terms of the GNU General Public License as published by the
#  Free Software Foundation; either version 2, or (at your option) any
#  later version: http://www.gnu.org/licenses/gpl.txt.

#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#-------------------------------------------------------------------------------

object PolyhedralComplex {
	
   user_method wcosheaf( $ ){
      my($pc, $p) = @_;
      my $G = $pc->HASSE_DIAGRAM->ADJACENCY;
      my $newblocks = new EdgeMap<Directed, Matrix>($G);
      my $newbases = new NodeMap<Directed, Matrix >($G);
      my $chosenBases = $pc->HASSE_DIAGRAM->CHOSEN_BASES;
      if ($p == 0){
         $newblocks = build_blocks_constant($pc);
         for(my $node = entire(nodes($G)); $node; ++$node){
            $newbases->[$$node] = new Matrix([[1]]);
         }
      } else{ 
         my $simpleBlocks = $pc->SIMPLE_BLOCKS;
         for (my $e=entire(edges($G)); $e; ++$e) {
            $newblocks->[$$e] = wedge_matrix($simpleBlocks->[$$e], $p);
         }
         for(my $node = entire(nodes($G)); $node; ++$node){
            $newbases->[$$node] = wedge_matrix($chosenBases->[$$node], $p);
         }
      }
      my $sheaf = $pc->add("COSHEAF", BLOCKS=>$newblocks, BASES=>$newbases);
      return $sheaf;
   }

      
      
   user_method wsheaf( $ ){
      my($pc, $p) = @_;
      my $G = $pc->HASSE_DIAGRAM->ADJACENCY;
      my $newblocks = new EdgeMap<Directed, Matrix>($G);
      my $newbases = new NodeMap<Directed, Matrix >($G);
      my $chosenBases = $pc->HASSE_DIAGRAM->CHOSEN_BASES;
      if ($p == 0){
         $newblocks = build_blocks_constant($pc);
         for(my $node = entire(nodes($G)); $node; ++$node){
            $newbases->[$$node] = new Matrix([[1]]);
         }
      } else{ 
         my $simpleBlocks = $pc->SIMPLE_BLOCKS;
         for (my $e=entire(edges($G)); $e; ++$e) {
            $newblocks->[$$e] = new Matrix(transpose(wedge_matrix($simpleBlocks->[$$e], $p)));
         }
         for(my $node = entire(nodes($G)); $node; ++$node){
            $newbases->[$$node] = wedge_matrix($chosenBases->[$$node], $p);
         }
      }
      my $cosheaf = $pc->add("SHEAF", BLOCKS=>$newblocks, BASES=>$newbases);
      return $cosheaf;
   }
   
   
   user_method compact_wsheaf( $ ){
      my($pc, $p) = @_;
      my $compactHD = $pc->COMPACTIFICATION;
      my $G = $compactHD->ADJACENCY;
      my $newblocks = new EdgeMap<Directed, Matrix>($G);
      my $newbases = new NodeMap<Directed, Matrix >($G);
      my $chosenBases = $pc->HASSE_DIAGRAM->CHOSEN_BASES;
      if ($p == 0){
         $newblocks = build_blocks_constant($pc);
         for(my $node = entire(nodes($G)); $node; ++$node){
            $newbases->[$$node] = new Matrix([[1]]);
         }
      } else{ 
      }
      my $cosheaf = $pc->add("COMPACT_SHEAF", BLOCKS=>$newblocks, BASES=>$newbases);
      return $cosheaf;
   }
}
