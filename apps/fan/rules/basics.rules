#  Copyright (c) 2016-2018
#  Lars Kastner (TU Berlin)
#  Kristin Shaw (University of Oslo)
#  Anna-Lena Winz (FU Berlin)

#  This program is free software; you can redistribute it and/or modify it
#  under the terms of the GNU General Public License as published by the
#  Free Software Foundation; either version 2, or (at your option) any
#  later version: http://www.gnu.org/licenses/gpl.txt.

#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#-------------------------------------------------------------------------------

object PolyhedralComplex {

   property SIMPLE_BLOCKS : EdgeMap<Directed, Matrix>;

   property CHOSEN_BASES : NodeMap<Directed, Matrix>;


   rule CHOSEN_BASES : VERTICES, HASSE_DIAGRAM.ADJACENCY, HASSE_DIAGRAM.FACES, FAN_DIM, LINEALITY_SPACE {
      my $lin = $this->LINEALITY_SPACE;
      my $d = $this->FAN_DIM - 1;
      my $vertices = $this->VERTICES;
      my $faces = $this->HASSE_DIAGRAM->FACES;
      my $G = $this->HASSE_DIAGRAM->ADJACENCY;
      my $result = new NodeMap<Directed, Matrix>($G);
      for(my $node = entire(nodes($G)); $node; ++$node){
         my $honestSigma = $faces->[$$node];
         if($honestSigma != new Set<Int>([-1])){
            my $vertSigma = $vertices->minor($honestSigma, All);
            my $p = new Polytope(POINTS=>$vertSigma, INPUT_LINEALITY=>$lin);
            if($p->FEASIBLE){
               my $aff = $p->AFFINE_HULL;
               $aff = $aff->minor(All, ~[0]);
               $result->[$$node] = null_space($aff);
            } else {
               $result->[$$node] = new Matrix(0, $d);
            }
         } else {
            $result->[$$node] = new Matrix(0, $d);
         }
      }
      $this->CHOSEN_BASES = $result;
   }

   
   rule SIMPLE_BLOCKS : HASSE_DIAGRAM.ADJACENCY, HASSE_DIAGRAM.DECORATION, FAN_DIM, CHOSEN_BASES {
      my $d = $this->FAN_DIM - 1;
      my $chosenBases = $this->CHOSEN_BASES;
      my $hd = $this->HASSE_DIAGRAM;
      my $G = $hd->ADJACENCY;
      my $result = new EdgeMap<Directed, Matrix>($G);
      my $decoration = $hd->DECORATION;

      for (my $e=entire(edges($G)); $e; ++$e) {
         my $sigmaBasis = $chosenBases->[$e->to_node];
         my $tauBasis = $chosenBases->[$e->from_node];
         $result->[$$e] = build_matrix($sigmaBasis, $tauBasis);
      }
      $this->SIMPLE_BLOCKS = $result;
   }
   
}


sub to_lattice_basis{
   my($A) = @_;
   my $Aint = new Matrix<Integer>(primitive($A));
   my ($D, $L, $R) = @{smith_normal_form($Aint)};
   return $R->minor([0..$A->rows()-1],All);
}
