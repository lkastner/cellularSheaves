
object PolyhedralComplex {

   property SIMPLE_BLOCKS : Map<Set<Set<Int> >, Matrix >;

   property CHOSEN_BASES : Map<Set<Int>, Matrix>;

   property ORIENTATIONS : Map<Set<Set<Int> >, Int >;

   rule CHOSEN_BASES : VERTICES, HASSE_DIAGRAM, FAN_DIM, LINEALITY_SPACE {
      my $result = new Map<Set<Int>, Matrix>();
      my $lin = $this->LINEALITY_SPACE;
      my $d = $this->FAN_DIM - 1;
      my $vertices = $this->VERTICES;
      my $hd = $this->HASSE_DIAGRAM;
      for(my $i=0; $i<=$d; $i++){
         my $sigmaDim = $d - $i;
         # print "Looking at dim ",$sigmaDim,"\n";
         my $sigmas = $hd->nodes_of_dim($sigmaDim);
         foreach my $sigma (@$sigmas) {
            my $honestSigma = $hd->FACES->[$sigma];
            my $vertSigma = $vertices->minor($honestSigma, All);
            my $p = new Polytope(POINTS=>$vertSigma, INPUT_LINEALITY=>$lin);
            if($p->FEASIBLE){
               my $aff = $p->AFFINE_HULL;
               $aff = $aff->minor(All, ~[0]);
               $result->{$honestSigma} = null_space($aff);
            } else {
               $result->{$honestSigma} = new Matrix(0, $d);
            }
         }
      }
      $this->CHOSEN_BASES = $result;
   }

   
   rule SIMPLE_BLOCKS : HASSE_DIAGRAM, FAN_DIM, CHOSEN_BASES {
      my $result = new Map<Set<Set<Int> >, Matrix>();
      my $d = $this->FAN_DIM - 1;
      my $chosenBases = $this->CHOSEN_BASES;
      my $hd = $this->HASSE_DIAGRAM;
      # print $d,"\n";
      for(my $i=0; $i<$d; $i++){
         my $sigmas = $hd->nodes_of_dim($d-$i);
         my $taus = $hd->nodes_of_dim($d-$i-1);
         foreach my $sigma (@$sigmas) {
            my $honestSigma = $hd->FACES->[$sigma];
            foreach my $tau (@$taus) {
               my $honestTau = $hd->FACES->[$tau];
               # print $honestSigma," ",$honestTau,"\n";
               my $keySet = new Set<Set<Int> >($honestSigma, $honestTau);
               my $sigmaBasis = $chosenBases->{$honestSigma};
               my $tauBasis = $chosenBases->{$honestTau};
               my $map;
               my $test = $honestSigma*$honestTau;
               if($test->size == $honestTau->size){
                  $map = build_matrix($sigmaBasis, $tauBasis);
               } else {
                  $map = zero_matrix($tauBasis->rows, $sigmaBasis->rows);
               }
               $result->{$keySet} = $map;
               # print $result->{$keySet}->rows()," ",$result->{$keySet}->cols(),"\n";
            }
         }
      }
      $this->SIMPLE_BLOCKS = $result;
   }
   
    	
 	rule ORIENTATIONS : HASSE_DIAGRAM, FAN_DIM, SIMPLE_BLOCKS, VERTICES, CHOSEN_BASES {
      # returns either 0, +1, -1 depending on the compatibility of thechosen ordered bases
      my $d = $this->FAN_DIM - 1;
      my $result = new Map<Set<Set<Int> >, Int>();
      my $blocks = $this->SIMPLE_BLOCKS;
      my $vertices = $this->VERTICES;
      my $hd = $this->HASSE_DIAGRAM;
      my $chosenBases = $this->CHOSEN_BASES;
      for(my $i=0; $i<$d; $i++){
         my $sigmas = $hd->nodes_of_dim($d-$i);
         my $taus = $hd->nodes_of_dim($d-$i-1);
         foreach my $sigma (@$sigmas) {
            my $honestSigma = $hd->FACES->[$sigma];
            foreach my $tau (@$taus) {
               my $honestTau = $hd->FACES->[$tau];
               my $keySet = new Set<Set<Int> >($honestSigma, $honestTau);
               my $block = $blocks->{$keySet};
               $result->{$keySet} = compute_orientation($honestSigma, $honestTau, $vertices, $chosenBases, $block);
            }
         } 
      }
      $this->ORIENTATIONS = $result;
   }

}


sub compute_orientation{
   my($sigma, $tau, $vertices, $chosenBases, $block) = @_;
   if(is_face($sigma, $tau)){
      return compute_orientation_for_face($sigma, $tau, $vertices, $chosenBases, $block);
   } else { 
      return 0;
   }
}


sub is_face{
   my($sigma, $tau) = @_;
   my $test = $sigma * $tau;
   return $test->size == $tau->size;
}


sub compute_orientation_for_face{
   my($sigma, $tau, $vertices, $chosenBases, $dxdMinus1) = @_;
   my $genVector = get_genVector($sigma, $tau, $vertices);
   my $sigmaBasis = $chosenBases->{$sigma};
   print "SigmaBasis:\n", $sigmaBasis,"\n",$genVector,"\n";
   my $relativeRow = new Matrix(build_matrix($sigmaBasis,  new Matrix($genVector)));
   my $baseChangeMatrix = new Matrix($relativeRow / $dxdMinus1);   
   if (det($baseChangeMatrix) >= 0){
      return 1;
   } else {
      return -1;
   }
}


sub get_genVector{
   my($sigma, $tau, $vertices) = @_;
   my $honestNotInTau = $sigma - $tau;
   my $indexNotInTau = $honestNotInTau->[0];
   my $vectorNotInTau = $vertices->[$indexNotInTau];
   my $genVector = $vectorNotInTau - $vertices->[$tau->[0]]; #This creates a vector in span of Sigma not in Tauand pointing same as Sigma
   $genVector = $genVector->slice(1);
   if ($genVector == zero_vector($genVector->dim)){
      if($vectorNotInTau->[0] == 0){
         $genVector = 2*$vectorNotInTau - $vertices->[$tau->[0]];
      } else {
         $genVector = $vectorNotInTau - 2*$vertices->[$tau->[0]];
      }
      $genVector = $genVector->slice(1);
   }
   return $genVector;
}



sub build_cone{
   my($vertices, $indexSet, $common) = @_;
   # print "Building cone: ",$indexSet,"\n";
   my $rays = new Matrix($vertices->minor($indexSet, All));
   # print $rays,"----\n";
   my $v = $vertices->[$common];
   # print $v,"\n----\n";
   $rays = new Matrix(map{$_-$v}@$rays);
   $rays = $rays->minor(All, ~[0]);
   # print $rays;
   return new Cone(INPUT_RAYS=>$rays);
}

# sub choose_basis{
#    my($A) = @_;
#    my @result = ();
#    my $desired = rank($A);
#    my $ambient = $A->cols();
#    my $zero = zero_vector($ambient);
#    my @gens = @$A;
#    @gens = grep($_ != $zero, @gens);
#    push @result, shift @gens;
#    my $test = new Matrix(@result);
#    while(rank($test) < $desired){
#       my $next = shift @gens;
#       if(rank($test / $next) > rank($test)){
#          push @result, $next;
#          $test = new Matrix(@result);
#       }
#    }
#    return $test;
# }


sub to_lattice_basis{
   my($A) = @_;
   my $Aint = new Matrix<Integer>(primitive($A));
   my ($D, $L, $R) = @{smith_normal_form($Aint)};
   return $R->minor([0..$A->rows()-1],All);
}


