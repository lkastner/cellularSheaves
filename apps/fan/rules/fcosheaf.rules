
object PolyhedralComplex {

   user_method fcosheaf( $ ){
      my($pc, $p) = @_;
      my $G = $pc->HASSE_DIAGRAM->ADJACENCY;
      my $newblocks = new EdgeMap<Directed, Matrix>($G);
      my $newbases = new Map<Set<Int> , Matrix >();
      if ($p == 0){
         $newblocks = build_blocks_constant($pc);
         $newbases = build_bases_f($pc, 0);
      } else{ 
         $newblocks = build_blocks_f($pc, $p); 
         $newbases = build_bases_f($pc, $p);
      }
      my $sheaf = $pc->add("COSHEAF", BLOCKS=>$newblocks, BASES=>$newbases);
      return $sheaf;
   }


	user_method constant_sheaf( ){
		my($pc) = @_;
		my $newblocks = build_blocks_constant($pc);
		my $const_sheaf = $pc->add("COSHEAF", BLOCKS => $newblocks);
		return $const_sheaf;
	}

}

sub find_max_containing{
   my($honestTau, $pc) = @_;
   my $max_cones = $pc->MAXIMAL_CONES;
   my @result = ();
   foreach my $sigma (@$max_cones) {
   		my $test = $sigma*$honestTau;
        if($test->size == $honestTau->size){
        	push @result, $sigma;
        }
    }
	return @result;
}


sub build_matrix_f{
	my($honestTau, $pc, $p) =@_;
	my $n = $pc->AMBIENT_DIM;
	my @max_cones_tau = find_max_containing($honestTau, $pc);
	my $cols = new Int(binomial($n, $p));
	my $generators  = zero_matrix(1, $cols);
	my $chosenBases = $pc->CHOSEN_BASES;  #this is really unnecessary, only need CHOSEN_BASES top cones.
	foreach my $sigma (@max_cones_tau) {
		my $wedged_basis = new Matrix wedge_matrix($chosenBases->{$sigma}, $p);	
		$generators = new Matrix( $generators / $wedged_basis);
	}	
	return choose_basis($generators);
}


sub build_blocks_f{ 
   my($pc, $p) =@_;
   my $d = $pc->FAN_DIM - 1;
   my $G = $pc->HASSE_DIAGRAM->ADJACENCY;
   my $faces = $pc->HASSE_DIAGRAM->FACES;
   my $newBlocks = new EdgeMap<Directed, Matrix>($G);
   for (my $e=entire(edges($G)); $e; ++$e) {
      my $honestTau = $faces->[$e->from_node];
      my $honestSigma = $faces->[$e->to_node];
      my $fpSigmaBasis = new Matrix (build_matrix_f($honestSigma, $pc, $p));
      my $fpTauBasis = new Matrix (build_matrix_f($honestTau, $pc, $p));

      my $map = build_matrix($fpTauBasis, $fpSigmaBasis);
      $newBlocks->[$$e] = new Matrix(transpose($map));
   }
   return $newBlocks; 
}


sub build_bases_f{ 
	my($pc, $p) =@_;
	my $d = $pc->FAN_DIM - 1;
	my $hd = $pc->HASSE_DIAGRAM;
	my $newBases = new Map<Set<Int> , Matrix >();
	for(my $i=0; $i<$d+1; $i++){
      my $sigmas = $hd->nodes_of_dim($d-$i);
      foreach my $sigma (@$sigmas) {
         my $honestSigma = $hd->FACES->[$sigma];
         my $keySet = new Set<Int> ($honestSigma);
         my $fpSigmaBasis = new Matrix([[1]]);
         if ($p ==0) {
         	  $fpSigmaBasis = new Matrix([[1]]);
         } else {
         		$fpSigmaBasis = new Matrix (build_matrix_f($honestSigma, $pc, $p));
         	}
         $newBases->{$keySet} = $fpSigmaBasis;
       }   
	}
	return $newBases; 
}



sub build_blocks_constant{
	my($pc) = @_;
	my $d = $pc->FAN_DIM - 1;
   my $G = $pc->HASSE_DIAGRAM->ADJACENCY;
   my $newBlocks = new EdgeMap<Directed, Matrix>($G);
   for (my $e=entire(edges($G)); $e; ++$e) {
      $newBlocks->[$$e] = new Matrix([[1]]);
   }
	return $newBlocks;	
} 
