#  Copyright (c) 2016-2018
#  Lars Kastner (TU Berlin)
#  Kristin Shaw (University of Oslo)
#  Anna-Lena Winz (FU Berlin)

#  This program is free software; you can redistribute it and/or modify it
#  under the terms of the GNU General Public License as published by the
#  Free Software Foundation; either version 2, or (at your option) any
#  later version: http://www.gnu.org/licenses/gpl.txt.

#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#-------------------------------------------------------------------------------

object PolyhedralFan {

   property ORIENTATIONS : EdgeMap<Directed, Int>;

   property INTERNAL_BASES : Map<Set<Int>, Matrix>;

   rule INTERNAL_BASES : RAYS, LINEALITY_SPACE, HASSE_DIAGRAM, FAN_DIM {
      my $rays = $this->RAYS;
      my $lineality = $this->LINEALITY_SPACE;
      my $d = $this->FAN_DIM - 1;
      my $hd = $this->HASSE_DIAGRAM;
      $this->INTERNAL_BASES = choose_bases_for_cones($rays, $lineality, $hd, $d);
   }

   rule ORIENTATIONS: HASSE_DIAGRAM.ADJACENCY, HASSE_DIAGRAM.DECORATION, FAN_DIM, INTERNAL_BASES{
      my $G = $this->HASSE_DIAGRAM->ADJACENCY;
      my $decoration = $this->HASSE_DIAGRAM->DECORATION;
      my $result = new EdgeMap<Directed, Int>($G);
      my $chosenBases = $this->INTERNAL_BASES;
      for (my $e=entire(edges($G)); $e; ++$e) {
         my $tau = $decoration->[$e->from_node]->face;
         my $sigma = $decoration->[$e->to_node]->face;
         $result->[$$e] = compute_orientation($sigma, $tau, $chosenBases);
      }
      $this->ORIENTATIONS = $result;
   }

}

sub choose_bases_for_cones{
   my($rays, $lineality, $hd, $d) = @_;
   my $result = new Map<Set<Int>, Matrix>();
   for my $key (@{$hd->nodes_of_dim_range(0,$d)}){
      my $face = $hd->FACES->[$key];
      my $Crays = $rays->minor($face, All);
      $result->{$face} = choose_basis($Crays/$lineality);
   }
   return $result;
}


sub compute_orientation{
   my($sigma, $tau, $chosenBases) = @_;
   if($sigma == new Set<Int>(-1)){
      # sigma is top node
      return 0;
   }
   if($tau->size == 0){
      # tau is empty
      return 0;
   }
   my $sigmaBasis = $chosenBases->{$sigma};
   my $tauBasis = $chosenBases->{$tau};
   return compute_orientation_for_face($sigmaBasis, $tauBasis);
}


sub is_face{
   my($sigma, $tau) = @_;
   my $test = $sigma * $tau;
   return $test->size == $tau->size;
}


sub compute_orientation_for_face{
   my($sigmaBasis, $tauBasis) = @_;
   my $genVector = get_genVector($sigmaBasis, $tauBasis);
   my $relativeRow = new Matrix(build_matrix($sigmaBasis,  new Matrix($genVector)));
   my $dxdMinus1 = build_matrix($sigmaBasis, $tauBasis);
   my $baseChangeMatrix = new Matrix($relativeRow / $dxdMinus1);   
   if (det($baseChangeMatrix) >= 0){
      return 1;
   } else {
      return -1;
   }
}


sub get_genVector{
   my($sigmaBasis, $tauBasis) = @_;
   my $tauRank = rank($tauBasis);
   for my $s (@$sigmaBasis){
      my $test = rank($tauBasis/$s);
      if($test > $tauRank){
         return $s;
      }
   }
   die "No good vector found.";
}
