INCLUDE
   orientation.rules
   basics.rules
   faces.rules
   complex.rules
   sheaves.rules
   wsheaf.rules
   fcosheaf.rules
   functors.rules

user_function wedge_matrix_cpp<Element=Rational>(Matrix, $ ) : c++ (include => "polymake/fan/linalg_tools.h");

user_function choose_basis_cpp<Element=Rational>(Matrix) : c++ (include => "polymake/fan/linalg_tools.h");

user_function build_matrix_cpp<Element=Rational>(Matrix,Matrix) : c++ (include => "polymake/fan/linalg_tools.h");

user_function assemble_matrix_cpp<Element=Rational>(Array<Set<Int>>, Array<Set<Int>>, Map<Set<Set<Int> >, Matrix>, Map<Set<Set<Int> >, Int>) : c++ (include => "polymake/fan/linalg_tools.h");


sub assemble_matrix{
   my($sigmas, $taus, $blocks, $orientations, $bases) = @_;
   if ($sigmas->size == 0){
   	   my $rowsize = 0; 
   	   foreach my $tau (@$taus) { 
   	   		$rowsize = $rowsize + $bases->{$tau}->cols;
	   	}
	   	return zero_matrix($rowsize, 0);
   }
   elsif ($taus->size ==0){
   		my $colsize = 0; 
   	   foreach my $sigma (@$sigmas) { 
   	   		$colsize = $colsize + $bases->{$sigma}->rows;
	   	}
	   	return zero_matrix(0, $colsize);
   } else { 
      my $firstSet = new Set<Set<Int> >($sigmas->[0], $taus->[0]);
      my $ncols = $sigmas->size * $blocks->{$firstSet}->cols;
      my $nrows = $taus->size * $blocks->{$firstSet}->rows;
      return assemble_matrix_cpp($sigmas, $taus, $blocks, $orientations);
   }
}


sub choose_basis{
   my($A) = @_;
   my $desired = rank($A);
   if($desired == 0){
      return zero_matrix($A->rows,0);
   }
   else{
      return choose_basis_cpp($A);
   }
}


sub build_matrix{
   my($bigger, $smaller) = @_;
   my $nrows = $smaller->rows;
   if ($nrows == 0){
      return zero_matrix(0,$bigger->rows);
   } else {
      return build_matrix_cpp($bigger,$smaller);
   }
}


sub wedge_matrix{
   my($A, $p) = @_;
   my $nrows = binomial($A->rows, $p);
   my $ncols = binomial($A->cols, $p);
   if(($nrows == 0) || ($ncols == 0)){
      return zero_matrix($nrows, $ncols);
   } else {
      return wedge_matrix_cpp($A, $p);
   }
}
