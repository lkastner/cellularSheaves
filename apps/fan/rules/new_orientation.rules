sub new_orientation {
   my($hd) = @_;
   my $graph = $hd->ADJACENCY;
   my $orientation = new EdgeMap<Directed, Int>($graph);
   my $bottom = $hd->BOTTOM_NODE;
   foreach my $neighbor (@{$graph->out_adjacent_nodes($bottom)}){
      $orientation->edge($bottom, $neighbor) = 1;
   }
   for(my $i=2; $i<$hd->rank; $i++){
      print "Level: $i\n";
      solve_level($hd, $i, $orientation);
   }
   return $orientation;
}

# my $pc = cube(3);
# 
# my $hd = $pc->HASSE_DIAGRAM;
# my $graph = $hd->ADJACENCY;
# 
# my $relevant = new Set<Pair<Int, Int>>();
# 
# my $indexMap = new Map<Pair<Int, Int>, Int>();
# my $orientation = new EdgeMap<Directed, Int>($graph);
# 
# my $bottom = $hd->BOTTOM_NODE;
# foreach my $neighbor (@{$graph->out_adjacent_nodes($bottom)}){
#    $orientation->edge($bottom, $neighbor) = 1;
# }
# 
# my $targetLevel = 2;
# my $firstTarget = $hd->nodes_of_rank(2)->[0];
# 
# print $orientation,"\n";
# solve_level($hd, 2, $orientation);
# print $orientation,"\n";
# solve_level($hd, 3, $orientation);
# print $orientation,"\n";
# solve_level($hd, 4, $orientation);
# print $orientation,"\n";

sub solve_level {
   my($hd, $targetLevel, $orientation) = @_;
   my $squares = get_all_squares($hd, $targetLevel);
   # print "Squares are: ",$squares,"\n";

   my $firstSquare = new Array<Int>($squares->[0]);
   $squares -= $firstSquare;
   print "First: ",$firstSquare,"\n";
   my ($u, $v0, $v1, $w) = @$firstSquare;
# print $graph->edge_exists($u, $v0),"\n";
# print $graph->edge_exists($u, $v1),"\n";
# print $graph->edge_exists($v0, $w),"\n";
# print $graph->edge_exists($v1, $w),"\n";
# print $orientation->edge($u, $v0),"\n";
# print $orientation->edge($u, $v1),"\n";
# print $orientation->edge($v0, $w),"\n";
# print $orientation->edge($v1, $w),"\n";
   $orientation->edge($v0, $w) = 1;
   solve_square($firstSquare, $orientation);
   solve_square($firstSquare, $orientation);
# print $orientation,"\n";

   while($squares->size() > 0){
      my $currentSquare;
      my $found = 0;
      #    print "Squares left: ",$squares->size(),"\n";
      foreach my $square (@$squares){
         if(is_solvable($square, $orientation)){
            print "Found: $square\n";
            $currentSquare = new Array<Int>($square);
            $found = 1;
            last;
         }
      }
      if($found == 0){
         $currentSquare = new Array<Int>($squares->[0]);
         print "Found none, Squares left: ",$squares->size(),", choosing $currentSquare\n";
         $orientation->edge($currentSquare->[1], $currentSquare->[3]) = 1;
      } 
      $squares -= $currentSquare;
      # print "Solving $currentSquare\n$squares\n";
      solve_square($currentSquare, $orientation);
      # print "Done solving\n";
   }
# print $orientation,"\n";
}

sub is_solvable {
   my($square, $or) = @_;
   # print $square->[0],"\n";
   # print "Check solvability of $square-\n";
   my ($u, $v0, $v1, $w) = decompose_square($square);
   # print "After decomp: ",$square,"\n";
   # print "u:",$u," v0:",$v0," v1:",$v1," w:",$w,"\n";
   return !($or->edge($v0,$w) == 0 && $or->edge($v1,$w) == 0);
}

sub decompose_square {
   my($square) = @_;
   # print "Decompose: ",$square,"\n";
   return ($square->[0], $square->[1], $square->[2], $square->[3]);
}

sub solve_square {
   my($square, $or) = @_;
   # print "Got square $square\n";
   if(!is_solvable($square, $or)){
      die "Square cannot be solved";
   } else {
      my ($u, $v0, $v1, $w) = decompose_square($square);
      # print $square,"\n";
      if($or->edge($v0,$w) != 0 && $or->edge($v1,$w) != 0){
         my $check = $or->edge($u, $v0) * $or->edge($v0, $w);
         $check += $or->edge($u, $v1) * $or->edge($v1, $w);
         if($check != 0){
            die "Square defect: $square";
         }
      } else {
         if($or->edge($v0, $w) == 0){
            my $tmp = $v1;
            $v1 = $v0;
            $v0 = $tmp;
         }
         my $sign = $or->edge($u, $v1) == 1 ? -1 : 1;
         $or->edge($v1, $w) = $sign * $or->edge($u, $v0) * $or->edge($v0, $w);
      }
   }
}



sub get_all_squares {
   my($hd, $targetLevel) = @_;
   my $graph = $hd->ADJACENCY;
   my $sourceLevel = $targetLevel -2;
   my $midLevel = $targetLevel -1;
   # print "Midlevel nodes: ",$hd->nodes_of_rank($midLevel),"\n";
   my $result = new Set<Array<Int>>();
   foreach my $target (@{$hd->nodes_of_rank($targetLevel)}){
      # print "Target is $target\n";
      my $prev = $graph->in_adjacent_nodes($target);
      # print "Parents are: $prev\n";
      foreach my $parent (@$prev){
         # print "Grandparents: ",$graph->in_adjacent_nodes($parent),"\n";
         foreach my $source (@{$graph->in_adjacent_nodes($parent)}){
            # print "Source: ",$source,"\n";
            # print "Children of $source: ",$graph->out_adjacent_nodes($source),"\n";
            my $other = $prev * $graph->out_adjacent_nodes($source);
            if($other->size() != 2){
               print "Other: $other\n";
               print "Target: $target\n";
               print "Source: $source\n";
               die "Something went wrong.\n";
            } else {
               my $square = new Array<Int>(4);
               $square->[0] = $source;
               $square->[1] = $other->[0];
               $square->[2] = $other->[1];
               $square->[3] = $target;
               $result += $square;
               # print "Adding $square\n";
            }
         }
      }
   }
   return $result;
}


